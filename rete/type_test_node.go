package rete

import "fmt"

// This is a kludge because I've not found a way in go to express a
// literal that identifies a data type.

// TypeTestRegistry maps the string naming a go type to a function
// that returns true if an interface represents an object of that type.
// Such functions are defined and put here by code generated bu the
// rule_compiler.
var TypeTestRegistry map[string] func(interface{}) bool = make(map[string] func(interface{}) bool)

/*
func init() {
  	EnsureTypeTestRegistered(["MyType"],
		func(i interface{}) bool { _, ok := i.(MyType); return ok })
}
*/

// EnsureTypeTestRegistered is called by code generated by the
// rule_compiler to populate TypeTestRegistry.
func EnsureTypeTestRegistered(name string, f func(i interface{}) bool) {
	if _, ok := TypeTestRegistry[name]; !ok {
		TypeTestRegistry[name] = f
	}
}

// TypeTestNode filters its incoming items by the specified type.
type TypeTestNode struct {
	// Node
	BasicNode
	typeName string
	testFunc func(i interface{}) bool
}

func MakeTypeTestNode(t string) *TypeTestNode {
	n := &TypeTestNode{typeName: t}
	n.typeName = t
	var ok bool
	if n.testFunc, ok = TypeTestRegistry[t]; !ok {
		panic(fmt.Sprintf("No registered type test function for %s", t))
	}
	n.label = fmt.Sprintf("type test %s", t)
	return n
}

func (n *TypeTestNode) TypeName() string { return n.typeName }

// Receive is part of the node interface.
func (n *TypeTestNode) Receive(item interface{}) {
	if n.testFunc(item) {
		n.Emit(item)
	}
}

// IsValid is part of the Node interface.
func (n *TypeTestNode) IsValid() bool {
	return true
}

// GetTypeTestNode finds or creates a Node that filters by the specified type t.
// n should be the root node of a rete.
func GetTypeTestNode(n Node, typeName string) *TypeTestNode {
	for _, output := range n.Outputs() {
		if output, ok := output.(*TypeTestNode); ok {
			if output.typeName == typeName {
				return output
			}
		}
	}
	o := MakeTypeTestNode(typeName)
	Connect(n, o)
	return o
}

package main

import "bytes"
import "fmt"
import "go/ast"
import "go/format"
import "go/importer"
import "go/parser"
import "go/token"
import "go/types"
import "golang.org/x/tools/go/ast/astutil"
import "os"
import "strconv"
import "strings"
import "text/template"
import "defimpl/util"

const rule_file_suffix string = "_rules.go"
const output_file_suffix string = "_rules_out.go"

const ruleNamePrefix = "rule_"

func ruleBaseName(ruleName string) string {
	return strings.TrimPrefix(ruleName, ruleNamePrefix)
}

func main() {
	fset := token.NewFileSet()
	files := []*ast.File{}
	// Parse files from the working directory
	pkgs, err := parser.ParseDir(fset, ".",
		func(fi os.FileInfo) bool {
			return !strings.HasSuffix(fi.Name(), output_file_suffix)
		}, 0)
	if err != nil {
		panic(err)
	}
	for _, pkg := range pkgs {
		for _, f := range pkg.Files {
			files = append(files, f)
		}
	}
	if len(files) == 0 {
		fmt.Fprintf(os.Stderr, "No files specified.")
		return
	}
	// Collect type information
	fmt.Printf("Collecting type information.\n")
	info := &types.Info{
		Types: make(map[ast.Expr]types.TypeAndValue),
		Defs:  make(map[*ast.Ident]types.Object),
		Uses:  make(map[*ast.Ident]types.Object),
	}
	conf := types.Config{
		Importer: importer.For("source", nil), // importer.Default(),
	}
	_, err = conf.Check(files[0].Name.Name, fset, files, info)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Type errors: %s\n", err)
		return
	}
	fmt.Printf("Type information collected.\n")
	// What rules do we have?
	for _, astFile := range files {
		// Check that the file name matches *_rules.go.
		filename := fset.Position(astFile.Pos()).Filename
		if !strings.HasSuffix(filename, rule_file_suffix) {
			continue
		}
		fmt.Printf("Considering file %s\n", fset.Position(astFile.Pos()).Filename)
		// If we find any rules in astFile then we'll need to create
		// an output file.  In that case decls won't be empty.
		newAstFile := &ast.File{
			Name:  ast.NewIdent(astFile.Name.Name),
			Decls: []ast.Decl{},
		}
		for _, decl := range astFile.Decls {
			spec := grokRuleDefinition(fset, astFile, newAstFile, decl, info)
			if spec != nil {
				addRuleCode(spec, fset, newAstFile)
			}
		}
		if len(newAstFile.Decls) > 0 {
			// These packages are required by the boiler
			// plate of the generated code and might not
			// be found in the source file, so we must add
			// them explicitly.
			astutil.AddImport(fset, newAstFile, "reflect")
			astutil.AddImport(fset, newAstFile, "goshua/rete")
			astutil.AddImport(fset, newAstFile, "goshua/rete/rule_compiler/runtime")
			errors := util.EnsureImports(fset, astFile, newAstFile)
			for _, err := range errors {
				fmt.Fprintf(os.Stderr, "Import error: %s\n", err)
			}
			// Write the file
			output_filename := strings.TrimSuffix(filename, rule_file_suffix) + output_file_suffix
			fmt.Printf("Writing %s\n", output_filename)

			out, err := os.Create(output_filename)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Can't create %s: %s", output_filename, err)
				return
			}
			defer out.Close()
			fmt.Fprintf(out, "// This file was automatically generated by %s from %s.\n",
				os.Args[0], fset.File(astFile.Package).Name())
			// The documentation for (go/printer).Fprint suggests that the
			// output of format.Node is more consistent with that of gofmt.
			format.Node(out, fset, newAstFile)
		}
	}
}

const NODE_TYPE_STRING = "goshua/rete/rule_compiler/runtime.runtime.Node"

func typeString(t types.Type) string {
	return types.TypeString(t,
		func (p *types.Package) string {
			return p.Path() + "." + p.Name()
		})
}

// grokRuleDefinition determines if decl looks like a rule definition,
// and if so returns a RuleSpec.
func grokRuleDefinition(fset *token.FileSet, astFile *ast.File, newAstFile *ast.File,
	decl ast.Decl, info *types.Info) *RuleSpec {
	// body.
	fd, ok := decl.(*ast.FuncDecl)
	if !ok {
		return (*RuleSpec)(nil)
	}
	if !strings.HasPrefix(fd.Name.Name, ruleNamePrefix) {
		return (*RuleSpec)(nil)
	}
	// Verify that the first parameter is type rete.Node:
	type_string := typeString(info.TypeOf(fd.Type.Params.List[0].Names[0]))
	if type_string != NODE_TYPE_STRING {
		return (*RuleSpec)(nil)
	}
	rule_name := ruleBaseName(fd.Name.Name)
	spec := &RuleSpec{
		Package:           astFile.Name.Name,
		RuleName:          rule_name,
		RuleFunctionName:  fd.Name.Name,
		RuleCallerName:    "call_" + rule_name,
		RuleInstallerName: "install_" + rule_name,
		RuleParameters:    []*ruleParameter{},
		RuleEmits:         []string{},
	}
	// Determine parameter types.
	// We assume here that the zeroth element of the params list, since
	// it's a rete.Node, has only one identifier.
	for _, field := range fd.Type.Params.List[1:] {
		for _, nameId := range field.Names {

			// types.TypeString with a nil Qualifier will always write
			// the package path.
			pt := types.TypeString(info.TypeOf(nameId), package_qualifier(astFile))
			name := nameId.Name
			spec.RuleParameters = append(spec.RuleParameters, &ruleParameter{
				Name:      name,
				ParamType: pt,
			})
		}
	}
	// All rule parameters have been determined.  Fill in
	// ruleParameter.Remaining for the convenience of the
	// code generation template.
	spec.fillRemaining()
	// Determine rule output types by finding calls to rete.Node.Emit
	ast.Inspect(decl, func(n ast.Node) bool {
		if n == nil {
			return false
		}
		c, ok := n.(*ast.CallExpr)
		if !ok {
			return true
		}
		sel, ok := c.Fun.(*ast.SelectorExpr)
		if !ok {
			return true
		}
		if receiver, ok := sel.X.(*ast.Ident); !ok ||
			typeString(info.TypeOf(receiver)) != NODE_TYPE_STRING {
			return true
		}
		if sel.Sel.Name == "Emit" {
			spec.RuleEmits = adjoin(spec.RuleEmits,
				types.TypeString(info.TypeOf(c.Args[0]),
					package_qualifier(astFile)))
			return false
		}
		return true
	})
	if len(spec.RuleEmits) == 0 {
		fmt.Fprintf(os.Stderr, "Rule %s doesn't call Emit.\n", rule_name)
	}
	return spec
}

// addRuleCode generates definitions for the rule and adds them to newAstFile.
func addRuleCode(spec *RuleSpec, fset *token.FileSet, newAstFile *ast.File) {
	writer := bytes.NewBufferString("")
	err := RuleTemplate.Execute(writer, spec)
	if err != nil {
		panic(err)
	}
	parsed, err := parser.ParseFile(fset, spec.RuleName, writer.String(), 0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", writer.String())
		panic(fmt.Sprintf("Errors:\n%s", err))
	}
	newAstFile.Decls = append(newAstFile.Decls, parsed.Decls...)
	return
}

func package_qualifier(f *ast.File) types.Qualifier {
	return func(pkg *types.Package) string {
		if pkg.Name() == f.Name.Name {
			return ""
		}
		return pkg.Name()
	}
}

// adjoin treats strs as a set and appends add on;y if it is not already present.
func adjoin(strs []string, add string) []string {
	for _, s := range strs {
		if s == add {
			return strs
		}
	}
	strs = append(strs, add)
	return strs
}

// RuleSpec is the parameter for the template that generate the code
// for a single rule.
type RuleSpec struct {
	Package           string
	RuleName          string
	RuleFunctionName  string
	RuleCallerName    string
	RuleInstallerName string
	RuleParameters    []*ruleParameter
	RuleEmits         []string
}

// *** I thing Remaining can go away.
// fillRemaining fills in the rs.RuleParameters[*].Remaining fields.
func (rs *RuleSpec) fillRemaining() {
	length := len(rs.RuleParameters)
	for i, rp := range rs.RuleParameters {
		rp.Remaining = length - i -1
	}
}

func (rs *RuleSpec) LastParam() *ruleParameter {
	return rs.RuleParameters[len(rs.RuleParameters)-1]
}

// InstallerJoinIndices returns indices into rs.RuleParameters for all
// but the last element.  They are returned in reverse order.
func (rs *RuleSpec) InstallerJoinIndices() []int {
	length := len(rs.RuleParameters)
	result := make([]int, length-1)
	for i := 0; i < length-1; i++ {
		result[length-2-i] = i
	}
	return result
}

// ruleParameter holds the name and type for a single parameter of a rule.
type ruleParameter struct {
	Name      string
	ParamType string
	// The number of parameters remaining after this one.
	// This is filled in by calling RuleSpec.fillRemaining before the
	// code template is called.
	Remaining int
}

// ParamTypeGood attempts to return a string for rp.ParamType that is safe
// to include in go source.
// ParamType might be of the form <package path>.<type name> rather than
// <package name>.<type name>, so fudge it.
func (rp *ruleParameter) ParamTypeGood() string {
	// I don't know what the right way to do this is, but this should
	// work for now.
	s := strings.Split(rp.ParamType, "/")
	return s[len(s)-1]
}

var RuleTemplate *template.Template = template.Must(template.New("RuleTemplate").Parse(`
package {{.Package}}

// Rule {{.RuleName}}:
func init() {
	var rule_spec runtime.Rule
	rule_spec = runtime.AddRule(
		"{{.RuleName}}",
		"{{.RuleFunctionName}}",
		func (root runtime.Node) {
			rete.InstallRule(root, rule_spec)
		},
		{{.RuleCallerName}},
		[]reflect.Type{
			{{range .RuleParameters -}}
				reflect.TypeOf(func(x {{.ParamTypeGood}}){}).In(0),
			{{end -}}
		},
		[]reflect.Type{
			{{range .RuleEmits -}}
				reflect.TypeOf(func(x {{.}}){}).In(0),
			{{end -}}
		})
}

{{with $rs := .}}

func {{$rs.RuleCallerName}}(node rete.Node, params []interface{}) {
	{{- range $i, $param := $rs.RuleParameters }}
		{{.Name}} := params[{{$i}}].({{$param.ParamTypeGood}})
	{{- end -}}
	{{template "CALL_RULE_FUNCTION" $rs}}
}


{{end}}{{/* end with */}}

{{define "CALL_RULE_FUNCTION"}}
	{{.RuleFunctionName}}(node,
		{{range .RuleParameters}}{{.Name}}, {{end}})
{{end}} {{/* end define */}}

`)) // End Template


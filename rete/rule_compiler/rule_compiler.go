package main

import "bytes"
import "fmt"
import "go/ast"
import "go/format"
import "go/importer"
import "go/parser"
import "go/token"
import "go/types"
import "golang.org/x/tools/go/ast/astutil"
import "os"
import "strconv"
import "strings"
import "text/template"

const rule_file_suffix string = "_rules.go"
const output_file_suffix string = "_rules_out.go"

const ruleNamePrefix = "rule_"

func ruleBaseName(ruleName string) string {
	return strings.TrimPrefix(ruleName, ruleNamePrefix)
}

func main() {
	fset := token.NewFileSet()
	files := []*ast.File{}
	// Parse files from the working directory
	pkgs, err := parser.ParseDir(fset, ".",
		func(fi os.FileInfo) bool {
			return !strings.HasSuffix(fi.Name(), output_file_suffix)
		}, 0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing directory:\n\t%s\n", err)
		return
	}
	for _, pkg := range pkgs {
		for _, f := range pkg.Files {
			files = append(files, f)
		}
	}
	if len(files) == 0 {
		fmt.Fprintf(os.Stderr, "No files specified.")
		return
	}
	// Collect type information
	fmt.Printf("Collecting type information.\n")
	info := &types.Info{
		Types: make(map[ast.Expr]types.TypeAndValue),
		Defs:  make(map[*ast.Ident]types.Object),
		Uses:  make(map[*ast.Ident]types.Object),
	}
	conf := types.Config{
		Importer: importer.For("source", nil), // importer.Default(),
	}
	_, err = conf.Check(files[0].Name.Name, fset, files, info)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Type errors: %s\n", err)
		return
	}
	// What rules do we have?
	for _, astFile := range files {
		// Check that the file name matches *_rules.go.
		filename := fset.Position(astFile.Pos()).Filename
		if !strings.HasSuffix(filename, rule_file_suffix) {
			continue
		}
		fmt.Printf("Considering file %s\n", fset.Position(astFile.Pos()).Filename)
		// If we find any rules in astFile then we'll need to create
		// an output file.  In that case decls won't be empty.
		newAstFile := &ast.File{
			Name:  ast.NewIdent(astFile.Name.Name),
			Decls: []ast.Decl{},
		}
		astutil.AddImport(fset, newAstFile, "reflect")
		astutil.AddImport(fset, newAstFile, "goshua/rete")
		astutil.AddImport(fset, newAstFile, "goshua/rete/rule_compiler/runtime")
		for _, decl := range astFile.Decls {
			grokRuleDefinition(fset, astFile, newAstFile, decl, info)
		}
		if len(newAstFile.Decls) > 0 {
			// Kludge to get all of the imports to appear in the output file.
			newAstFile.Decls[0].(*ast.GenDecl).Lparen = token.Pos(1) 
			// Write the file
			output_filename := strings.TrimSuffix(filename, rule_file_suffix) + output_file_suffix
			fmt.Printf("Writing %s\n", output_filename)

			out, err := os.Create(output_filename)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Can't create %s: %s", output_filename, err)
				return
			}
			defer out.Close()
			fmt.Fprintf(out, "// This file was automatically generated by %s from %s.\n",
				os.Args[0], fset.File(astFile.Package).Name())
			// The documentation for (go/printer).Fprint suggests that the
			// output of format.Node is more consistent with that of gofmt.
			format.Node(out, fset, newAstFile)
		}
	}
}

// grokRuleDefinition determines if decl looks like a rule definition,
// and if so returns declarations to be added to the output file.
func grokRuleDefinition(fset *token.FileSet, astFile *ast.File, newAstFile *ast.File, decl ast.Decl, info *types.Info) {
	fd, ok := decl.(*ast.FuncDecl)
	if !ok {
		return
	}
	if !strings.HasPrefix(fd.Name.Name, ruleNamePrefix) {
		return
	}
	// Verify that the first parameter is type rete.Node and note identifier.
	if !strings.HasSuffix(info.TypeOf(fd.Type.Params.List[0].Names[0]).String(), "rete.Node") {
		return
	}
	rule_name := ruleBaseName(fd.Name.Name)
	spec := &RuleSpec{
		Package:           astFile.Name.Name,
		RuleName:          rule_name,
		RuleFunctionName:  fd.Name.Name,
		RuleCallerName:    "call_" + rule_name,
		RuleInstallerName: "install_" + rule_name,
		RuleParameters:    []*ruleParameter{},
		RuleEmits:         []string{},
	}
	// Determine parameter types.
	// We assume here that the zeroth element of the params list, since
	// it's a rete.Node, has only one identifier.
	for _, field := range fd.Type.Params.List[1:] {
		for _, nameId := range field.Names {

			// types.TypeString with a nil Qualifier will always write
			// the package path.
			pt := info.TypeOf(nameId).String()
			pt = normalizePackage(fset, newAstFile, pt)
			name := nameId.Name
			spec.RuleParameters = append(spec.RuleParameters, &ruleParameter{
				Name:      name,
				ParamType: pt,
			})
		}
	}
	// All rule parameters have been determined.  Fill in
	// ruleParameter.Remaining for the cionvenience of the
	// code generation template.
	spec.fillRemaining()
	// Determine rule output types by finding calls to rete.Node.Emit
	ast.Inspect(decl, func(n ast.Node) bool {
		if n == nil {
			return false
		}
		c, ok := n.(*ast.CallExpr)
		if !ok {
			return true
		}
		sel, ok := c.Fun.(*ast.SelectorExpr)
		if !ok {
			return true
		}
		if receiver, ok := sel.X.(*ast.Ident); !ok ||
			info.TypeOf(receiver).String() != "goshua/rete.Node" {
			return true
		}
		if sel.Sel.Name == "Emit" {
			fmt.Printf("%s emits %s\n", rule_name, info.TypeOf(c.Args[0]).String())
			spec.RuleEmits = adjoin(spec.RuleEmits,
				normalizePackage(fset, newAstFile,
					info.TypeOf(c.Args[0]).String()))
			return false
		}
		return true
	})
	if len(spec.RuleEmits) == 0 {
		fmt.Fprintf(os.Stderr, "Rule %s doesn't call Emit.\n", rule_name)
	}
	// Generate new definitions for the rule
	writer := bytes.NewBufferString("")
	err := RuleTemplate.Execute(writer, spec)
	if err != nil {
		panic(err)
	}
	parsed, err := parser.ParseFile(fset, spec.RuleName, writer.String(), 0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", writer.String())
		panic(fmt.Sprintf("Errors:\n%s", err))
	}
	newAstFile.Decls = append(newAstFile.Decls, parsed.Decls...)
	return
}

// normalizePackage makes sure the type name s doesn't contain a package path.
// If there is a package path it is added to the imports of astFile.
func normalizePackage(fset *token.FileSet, astFile *ast.File, s string) string {
	unq := func(s string) string {
		s1, err := strconv.Unquote(s)
		if err != nil {
			return s
		}
		return s1
	}
	split := strings.Split(s, ".")
	// If pt has a package path prefix then make sure that package is imported,
	// unless its the package of the source file.
	// ***** We're not coping with the possibility of
	// ***** collision with another package name.
	if len(split) > 1 {
		// ***** We should make sure the whole package path matches.
		if strings.HasSuffix(split[0], astFile.Name.Name) {
			return split[1]
		}
		astutil.AddImport(fset, astFile, split[0])
		for _, i := range astFile.Imports {
			p := unq(i.Path.Value)
			if p == split[0] {
				var pkg string
				if i.Name == nil {
					split2 := strings.Split(p, "/")
					pkg = split2[len(split2) - 1]
				} else {
					pkg = i.Name.Name
				}
				fixed := fmt.Sprintf("%s.%s", pkg, split[1])
				return fixed
			}
		}
	}
	return s
}

// adjoin treats strs as a set and appends add on;y if it is not already present.
func adjoin(strs []string, add string) []string {
	for _, s := range strs {
		if s == add {
			return strs
		}
	}
	strs = append(strs, add)
	return strs
}

// RuleSpec is the parameter for the template that generate the code
// for a single rule.
type RuleSpec struct {
	Package           string
	RuleName          string
	RuleFunctionName  string
	RuleCallerName    string
	RuleInstallerName string
	RuleParameters    []*ruleParameter
	RuleEmits         []string
}

// fillRemaining fills in the rs.RuleParameters[*].Remaining fields.
func (rs *RuleSpec) fillRemaining() {
	length := len(rs.RuleParameters)
	for i, rp := range rs.RuleParameters {
		rp.Remaining = length - i -1
	}
}

func (rs *RuleSpec) LastParam() *ruleParameter {
	return rs.RuleParameters[len(rs.RuleParameters)-1]
}

// InstallerJoinIndices returns indices into rs.RuleParameters for all
// but the last element.  They are returned in reverse order.
func (rs *RuleSpec) InstallerJoinIndices() []int {
	length := len(rs.RuleParameters)
	result := make([]int, length-1)
	for i := 0; i < length-1; i++ {
		result[length-2-i] = i
	}
	return result
}

// ruleParameter holds the name and type for a single parameter of a rule.
type ruleParameter struct {
	Name      string
	ParamType string
	// The number of parameters remaining after this one.
	// This is filled in by calling RuleSpec.fillRemaining before the
	// code template is called.
	Remaining int
}

// ParamTypeGood attempts to return a string for rp.ParamType that is safe
// to include in go source.
// ParamType might be of the form <package path>.<type name> rather than
// <package name>.<type name>, so fudge it.
func (rp *ruleParameter) ParamTypeGood() string {
	// I don't know what the right way to do this is, but this should
	// work for now.
	s := strings.Split(rp.ParamType, "/")
	return s[len(s)-1]
}

var RuleTemplate *template.Template = template.Must(template.New("RuleTemplate").Parse(`
package {{.Package}}

func init() {
	runtime.AddRule("{{.RuleName}}",
		"{{.RuleFunctionName}}",
		{{.RuleInstallerName}},
		{{.RuleCallerName}},
		[]reflect.Type{
			{{range .RuleParameters}}
				reflect.TypeOf(func(x {{.ParamTypeGood}}){}).In(0),
			{{end}}
		},
		[]reflect.Type{
			{{range .RuleEmits}}
				reflect.TypeOf(func(x {{.}}){}).In(0),
			{{end}}
		})
}

{{with $rs := .}}

func {{$rs.RuleInstallerName}}(root_node rete.Node) {
	{{range $rs.RuleParameters}}
		{{.Name}} := rete.GetTypeTestNode(root_node,
			reflect.TypeOf(func(x {{.ParamTypeGood}}){}).In(0))
	{{end}}
	var previous rete.Node = {{$rs.LastParam.Name}}
	{{range $i := $rs.InstallerJoinIndices}}
		{{with $p := index $rs.RuleParameters $i}}
			previous = rete.Join("{{$rs.RuleName}}-{{$i}}", {{$p.Name}}, previous)
		{{end}}
	{{end}}
	ruleNode := rete.MakeFunctionNode("{{$rs.RuleName}}", {{$rs.RuleCallerName}})
	rete.Connect(previous, ruleNode)
	rete.Connect(ruleNode, root_node)
}

{{if eq (len $rs.RuleParameters) 1}}
func {{$rs.RuleCallerName}}(node rete.Node, i interface{}) {
	{{with $firstParam := index $rs.RuleParameters 0}}
		{{$firstParam.Name}} := i.({{$firstParam.ParamTypeGood}})
	{{end}}
	{{template "CALL_RULE_FUNCTION" $rs}}
}
{{else}}
func {{$rs.RuleCallerName}}(node rete.Node, i interface{}) {
	joinResult := i.(rete.JoinResult)
	{{/*
		Bind each of the rule parameters to the corresponding element of
		joinResult.
	*/}}
	{{/* The variable __jr is used to walk down the parameters list. */}}
	var __jr rete.JoinResult = joinResult
	{{/* n parameters, n-1 joins, n-2 CDRs. */}}
	{{range $p := $rs.RuleParameters}}
		{{if ge $p.Remaining 1}}
			{{$p.Name}} := __jr[0].({{$p.ParamTypeGood}})
		{{end}}
		{{if ge $p.Remaining 2}}
			__jr = __jr[1].(rete.JoinResult)
		{{end}}
	{{end}}
	{{with $lastParam := $rs.LastParam}}
		{{$lastParam.Name}} := __jr[1].({{$lastParam.ParamTypeGood}})
	{{end}}
	{{template "CALL_RULE_FUNCTION" $rs}}
}
{{end}}
{{end}}{{/* end with */}}

{{define "CALL_RULE_FUNCTION"}}
	{{.RuleFunctionName}}(node,
		{{range .RuleParameters}}{{.Name}}, {{end}})
{{end}} {{/* end define */}}

`)) // End Template


// catalog_rule_type_info is run after rule_compiler.  It processes
// the output of rule_compiler, updating the runtime.Rule objects in
// runtime.AllRules to include type information for what each rule
// might emit.

package main

import "fmt"
import "go/ast"
import "go/format"
import "go/importer"
import "go/parser"
import "go/token"
import "go/types"
import "os"
import "regexp"
import "strings"


func main() {
	fset := token.NewFileSet()
	files := []*ast.File{}
	// Parse files from the working directory
	pkgs, err := parser.ParseDir(fset, ".", nil, 0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing directory:\n\t%s\n", err)
		return
	}
	for _, pkg := range pkgs {
		for _, f := range pkg.Files {
			files = append(files, f)
		}
	}
	if len(files) == 0 {
		fmt.Fprintf(os.Stderr, "No files specified.")
		return
	}
	// Initialize the output ast
	newAstFile := &ast.File{
		Name:     ast.NewIdent(files[0].Name.Name),
		Decls:    []ast.Decl{
			makeImportDecl("goshua/rete/rule_compiler/runtime"),
			&ast.FuncDecl{
				Name: ast.NewIdent("init"),
				Type: &ast.FuncType{
					Params: &ast.FieldList{},
					Results: nil,
				},
				Body: &ast.BlockStmt{},
			},
		},
	}
	statements := []ast.Stmt{}
	// Collect type information
	fmt.Printf("Collecting type information.\n")
	info := &types.Info{
		Types: make(map[ast.Expr]types.TypeAndValue),
		Defs:  make(map[*ast.Ident]types.Object),
		Uses:  make(map[*ast.Ident]types.Object),
	}
	conf := types.Config{
		Importer: importer.For("source", nil),    // importer.Default(),
	}
	_, err = conf.Check(files[0].Name.Name, fset, files, info)
    if err != nil {
		fmt.Fprintf(os.Stderr, "Type errors: %s\n", err)
		return
	}
	// What rules do we have?
	for _, astFile := range files {
		fmt.Printf("Considering file %s\n", fset.Position(astFile.Pos()).Filename)
		for _, decl := range astFile.Decls {
			if g := grokRuleFunction(decl, info); g != nil {
				statements = append(statements, &ast.ExprStmt{
					X: mustParseExpr(fset, fmt.Sprintf(`runtime.SetEmitTypes("%s", []string{%s})`,
						g.ruleName,
						strings.Join(quote(g.emitTypes), ", "))),
				})
			}
		}
	}
	newAstFile.Decls[len(newAstFile.Decls) - 1].(*ast.FuncDecl).Body.List = statements
	writeFile(fset, newAstFile, "rule_emits.go")
}


func quote(strs []string) []string {
	for i, s := range strs {
		strs[i] = fmt.Sprintf("%q", s)
	}
	return strs
}


var ruleFunctionRe *regexp.Regexp = regexp.MustCompile("([A-Za-z0-9_]+)Function")

type groked struct {
	ruleName string
	paramTypes []string
	emitTypes []string
}

func grokRuleFunction(d ast.Decl, info *types.Info) *groked {
	fd, ok := d.(*ast.FuncDecl)
	if !ok {
		return nil
	}
	g := &groked{}
	match := ruleFunctionRe.FindStringSubmatch(fd.Name.Name)
	if len(match) != 2 {
		return nil
	}
	g.ruleName = match[1]
	testField := func(f *ast.Field, typ string) bool {
		return len(f.Names) == 1 && types.ExprString(f.Type) == typ
	}
	if !testField(fd.Type.Params.List[0], "rete.Node") ||
		!testField(fd.Type.Params.List[1], "interface{}") ||
		fd.Type.Results != nil {
		return nil
	}
	exprType := func(e ast.Expr) string {
		if t, ok := info.Types[e]; ok {
			return t.Type.String()
		}
		panic(fmt.Sprintf("No type info for %s", e))
	}
	ast.Inspect(d, func(n ast.Node) bool {
		if n == nil {
			return false
		}
		c, ok := n.(*ast.CallExpr)
		if !ok {
			return true
		}
		sel, ok := c.Fun.(*ast.SelectorExpr)
		if !ok {
			return true
		}
		// *** Can we tell if the type of sel.X is rete.Node?  Maybe using type checker?  sel.X.(*ast.Ident).Obj doesn't seem helpful.
		if i, ok := sel.X.(*ast.Ident); !ok || i.Name != "__node" {
			return true
		}
		if sel.Sel.Name == "Emit" {
			// *** Need to prevent duplicates.
			g.emitTypes = append(g.emitTypes, exprType(c.Args[0]))
			return false
		}
		return true
	})
	return g
}

var parsedExprCounter int = 0

func mustParseExpr(fset *token.FileSet, code string) ast.Expr {
	e, err := parser.ParseExprFrom(fset,
		fmt.Sprintf("mustParseExpr_%d", parsedExprCounter),
		code, 0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", code)
		panic(err)
	}
	parsedExprCounter += 1
	return e
}


// Copied from goshua/rete/rule_compiler/utils.go
func writeFile(fset *token.FileSet, astf *ast.File, filename string) {
	out, err := os.Create(filename)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Can't create %s: %s", filename, err)
		return
	}
	fmt.Fprintf(out, "// This file was automatically generated by %s from %s.\n",
		os.Args[0], filename)
	// The documentation for (go/printer).Fprint suggests that the
	// output of format.Node is more consistent with that of gofmt.
	format.Node(out, fset, astf)
	out.Close()
}


// Copied from goshua/rete/rule_compiler/ast_helpers.go
func makeImportSpec(pkgName string) *ast.ImportSpec {
	return &ast.ImportSpec{
		Path: &ast.BasicLit{ Kind: token.STRING, Value: `"` + pkgName + `"`,
		},
	}
}

// Copied from goshua/rete/rule_compiler/ast_helpers.go
func makeImportDecl(pkgName string) *ast.GenDecl {
	return &ast.GenDecl{
		Tok: token.IMPORT,
		Specs: []ast.Spec{ makeImportSpec(pkgName) },
	}
}


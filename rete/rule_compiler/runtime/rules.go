// Package runtime defines the runtime data structures that are
// created by the rule_compiler.

package runtime

import "goshua/rete"

type Rule interface {
	Name() string

	// Inserter adds the implementation of the rule to the rete
	// represented by this given root node.
	Inserter() func(rete.Node)

	// TestAndAssertFunction is the function that implements the
	// testing and emiting of results for the rule.
	TestAndAssertFunction() func(rete.Node, interface{})

	// ParamTypes is the names of the types of the rule's parameters.
	ParamTypes() []string

	// EmitTypess contains the names of the types of objects that the rule can Emit.
	EmitTypes() []string
}

// AllRules is a catalog describing all compiled rules that are loaded
// into the program
var AllRules []Rule = []Rule{}

// AddRule adds a rule to AllRules.  It is called by the code that is
// generated by the rule_compiler.
func AddRule(name string,
		inserter func(rete.Node),
		testAndAssertFunction func(rete.Node, interface{}),
		paramTypes []string) {
	AllRules = append(AllRules, &rule{
		name: name,
		inserter: inserter,
		testAndAssertFunction: testAndAssertFunction,
		paramTypes: paramTypes,
	})
}

type rule struct {
	name string
	inserter func(rete.Node)
	testAndAssertFunction func(rete.Node, interface{})
	paramTypes []string
	emitTypes []string
}

func (r *rule) Name() string { return r.name }

func (r *rule) Inserter() func(rete.Node) { return r.inserter }

func (r *rule) TestAndAssertFunction() func(rete.Node, interface{}) {
	return r.testAndAssertFunction
}

func (r *rule) ParamTypes() []string { return r.paramTypes }

func (r *rule) EmitTypes() []string { return r.emitTypes }

func SetEmitTypes(rule_name string, emitTypes []string) {
	for _, r := range AllRules {
		if r.Name() == rule_name {
			r.(*rule).emitTypes = emitTypes
			break
		}
	}
}
